(function () {

    // Extract argument names (except first)
    var getArgs = function (args) {
        if (args.length <= 1) return null;
        var result = [];
        for (var i = 1; i < args.length; i++) {
            result.push(args[i]);
        }
        return result;
    };

    // Normalize arguments length
    var normalizeArgs = function (args, len) {
        var result = [];
        for (var i = 0; i < args.length; i++) {
            result.push(args[i]);
        }
        while (result.length < len) {
            result.push(undefined);
        }
        return result;
    };

    // Init async powerpack
    var init = function (Jscex) {
        if (Jscex.modules["async-powerpack"]) return;

        if (!Jscex.modules.async) {
            throw Error('Missing essential components, please initialize "jscex-async" module first.');
        }

        var Async = Jscex.Async;
        var Task = Async.Task;
        var CanceledError = Async.CanceledError;

        // Sleep task
        Async.sleep = function (time, token) {
            return Task.create(function (t) {
                if (token && token.isCancellationRequested) {
                    t.complete("failure", new CanceledError());
                }

                var timer, cancel;
                if (token) {
                    cancel = function () {
                        clearTimeout(timer);
                        t.complete("failure", new CanceledError());
                    };
                }

                timer = setTimeout(function () {
                    token && token.unregister(cancel);
                    t.complete("success");
                }, time);

                token && token.register(cancel);
            });
        };

        // Event task
        Async.onEvent = function (target, event, token) {
            return Task.create(function (t) {
                if (token && token.isCancellationRequested) {
                    t.complete("failure", new CanceledError());
                }

                var remove = function () {
                    if (target.removeEventListener) target.removeEventListener(event, handler);
                    else if (target.removeListener) target.removeListener(event, handler);
                    else target.detachEvent(event, handler);
                };

                var handler, cancel;
                if (token) {
                    cancel = function () {
                        remove();
                        t.complete("failure", new CanceledError());
                    };
                }

                handler = function (e) {
                    token && token.unregister(cancel);
                    remove();
                    t.complete("success", e);
                };

                if (target.addEventListener) target.addEventListener(event, handler);
                else if (target.addListener) target.addListener(event, handler);
                else target.attachEvent(event, handler);

                token && token.register(cancel);
            });
        };

        // Wait for all tasks
        Task.whenAll = function () {
            var tasks = {};
            var isArray;

            if (arguments.length === 1) {
                var arg = arguments[0];
                if (Task.isTask(arg)) {
                    tasks[0] = arg;
                    isArray = true;
                } else {
                    tasks = arg;
                    isArray = Object.prototype.toString.call(tasks) === "[object Array]";
                }
            } else {
                for (var i = 0; i < arguments.length; i++) {
                    tasks[i] = arguments[i];
                }
                isArray = true;
            }

            return Task.create(function (t) {
                var pending = {};
                var results = isArray ? [] : {};
                var count = 0;

                for (var k in tasks) {
                    if (Task.isTask(tasks[k])) {
                        pending[tasks[k].id] = k;
                        if (tasks[k].status === "ready") tasks[k].start();
                    }
                }

                var onComplete = function (task) {
                    if (task.error) {
                        t.complete("failure", task.error);
                        return;
                    }
                    results[pending[task.id]] = task.result;
                    delete pending[task.id];
                    count--;
                    if (count === 0) t.complete("success", results);
                };

                for (var id in pending) {
                    var task = tasks[pending[id]];
                    if (task.status === "succeeded") {
                        results[pending[id]] = task.result;
                        delete pending[task.id];
                    } else {
                        count++;
                        task.addEventListener("complete", onComplete);
                    }
                }

                if (count === 0) t.complete("success", results);
            });
        };

        // Wait for any task
        Task.whenAny = function () {
            var tasks = {};
            if (arguments.length === 1) {
                var arg = arguments[0];
                Task.isTask(arg) ? tasks[0] = arg : tasks = arg;
            } else {
                for (var i = 0; i < arguments.length; i++) {
                    tasks[i] = arguments[i];
                }
            }

            return Task.create(function (t) {
                var map = {};
                for (var k in tasks) {
                    if (Task.isTask(tasks[k])) {
                        map[tasks[k].id] = k;
                        if (tasks[k].status === "ready") tasks[k].start();
                    }
                }

                var done = function (task) {
                    t.complete("success", {
                        key: map[task.id],
                        task: task
                    });
                };

                for (var id in map) {
                    tasks[map[id]].addEventListener("complete", done);
                }
            });
        };

        // Jscexify helpers
        Async.Jscexify = Async.Jscexify || {};
        var J = Async.Jscexify;

        J.fromStandard = function (fn) {
            var names = getArgs(arguments);
            return function () {
                var self = this;
                var args = normalizeArgs(arguments, fn.length - 1);
                return Task.create(function (t) {
                    args.push(function (err, result) {
                        if (err) t.complete("failure", err);
                        else t.complete("success", result);
                    });
                    fn.apply(self, args);
                });
            };
        };

        J.fromCallback = function (fn) {
            var names = getArgs(arguments);
            return function () {
                var self = this;
                var args = normalizeArgs(arguments, fn.length - 1);
                return Task.create(function (t) {
                    args.push(function (result) {
                        t.complete("success", result);
                    });
                    fn.apply(self, args);
                });
            };
        };

        Jscex.modules["async-powerpack"] = true;
    };

    // Module exports
    if (typeof require === "function" && typeof module !== "undefined" && module.exports) {
        module.exports.init = init;
    } else if (typeof define === "function" && !define.amd) {
        define("jscex-async-powerpack", ["jscex-async"], function (j, f, h) {
            h.exports.init = init;
        });
    } else if (typeof define === "function" && define.amd) {
        define("jscex-async-powerpack", ["jscex-async"], function () {
            return { init: init };
        });
    } else {
        if (typeof Jscex === "undefined") {
            throw Error('Missing the root object, please load "jscex" module first.');
        }
        init(Jscex);
    }

})();
