(function () {

    // Cancellation error
    var CanceledError = function () { };
    CanceledError.prototype = {
        isCancellation: true,
        message: "The task has been cancelled."
    };

    // Task ID seed
    if (typeof __jscex__async__taskIdSeed === "undefined") {
        __jscex__async__taskIdSeed = 0;
    }

    // Check if object is a Task
    var isTask = function (obj) {
        return typeof obj.start === "function" &&
            typeof obj.addEventListener === "function" &&
            typeof obj.removeEventListener === "function" &&
            typeof obj.complete === "function";
    };

    // Initialize async module
    var initAsync = function (Jscex) {

        if (Jscex.modules.async) return;

        /* ---------------- Cancellation Token ---------------- */

        var CancellationToken = function () { };
        CancellationToken.prototype = {
            register: function (handler) {
                if (this.isCancellationRequested) handler();
                if (!this._handlers) this._handlers = [];
                this._handlers.push(handler);
            },

            unregister: function (handler) {
                if (this._handlers) {
                    var idx = this._handlers.indexOf(handler);
                    if (idx >= 0) this._handlers.splice(idx, 1);
                }
            },

            cancel: function () {
                if (!this.isCancellationRequested) {
                    this.isCancellationRequested = true;
                    var handlers = this._handlers;
                    delete this._handlers;
                    for (var i = 0; i < handlers.length; i++) {
                        try {
                            handlers[i]();
                        } catch (e) {
                            Jscex.logger.warn(
                                "[WARNING] Cancellation handler threw an error: " + e
                            );
                        }
                    }
                }
            },

            throwIfCancellationRequested: function () {
                if (this.isCancellationRequested) {
                    throw new CanceledError();
                }
            }
        };

        /* ---------------- Task Implementation ---------------- */

        var Task = function (delegate) {
            this.id = ++__jscex__async__taskIdSeed;
            this._delegate = delegate;
            this._listeners = {};
            this.status = "ready";
        };

        Task.prototype = {

            start: function () {
                if (this.status !== "ready") {
                    throw Error('Task can only be started in "ready" status.');
                }
                this.status = "running";
                this._delegate(this);
            },

            complete: function (type, value) {
                if (this.status !== "running") {
                    throw Error(
                        'The "complete" method can only be called in "running" status.'
                    );
                }

                var listeners = this._listeners;
                delete this._listeners;

                if (type === "success") {
                    this.result = value;
                    this.status = "succeeded";
                    this._notify("success", listeners.success);
                } else if (type === "failure") {
                    this.error = value;
                    this.status = value.isCancellation ? "canceled" : "faulted";
                    this._notify("failure", listeners.failure);
                } else {
                    throw Error("Unsupported type: " + type);
                }

                this._notify("complete", listeners.complete);

                if (this.error && !listeners.failure && !listeners.complete) {
                    Jscex.logger.warn(
                        "[WARNING] An unhandled error occurred: " + this.error
                    );
                }
            },

            _notify: function (type, handlers) {
                if (!handlers) return;
                for (var i = 0; i < handlers.length; i++) {
                    try {
                        handlers[i](this);
                    } catch (e) {
                        Jscex.logger.warn(
                            "[WARNING] The task's " + type +
                            " listener threw an error: " + e
                        );
                    }
                }
            },

            addEventListener: function (type, handler) {
                if (!this._listeners) return;
                if (!this._listeners[type]) this._listeners[type] = [];
                this._listeners[type].push(handler);
            },

            removeEventListener: function (type, handler) {
                if (!this._listeners) return;
                var list = this._listeners[type];
                if (!list) return;
                var idx = list.indexOf(handler);
                if (idx >= 0) list.splice(idx, 1);
            }
        };

        Task.create = function (delegate) {
            return new Task(delegate);
        };

        Task.isTask = isTask;

        /* ---------------- Async Builder ---------------- */

        var AsyncBuilder = function () { };
        AsyncBuilder.prototype = {

            Start: function (ctx, task) {
                return Task.create(function (t) {
                    task.next(ctx, function (type, value) {
                        if (type === "normal" || type === "return") {
                            t.complete("success", value);
                        } else if (type === "throw") {
                            t.complete("failure", value);
                        } else {
                            throw Error("Unsupported type: " + type);
                        }
                    });
                });
            },

            Bind: function (task, func) {
                return {
                    next: function (ctx, next) {
                        var handler = function (t) {
                            if (t.error) {
                                next("throw", t.error);
                            } else {
                                var result;
                                try {
                                    result = func.call(ctx, t.result);
                                } catch (e) {
                                    next("throw", e);
                                    return;
                                }
                                result.next(ctx, next);
                            }
                        };

                        if (task.status === "ready") {
                            task.addEventListener("complete", handler);
                            task.start();
                        } else if (task.status === "running") {
                            task.addEventListener("complete", handler);
                        } else {
                            handler(task);
                        }
                    }
                };
            }
        };

        // Inherit from BuilderBase
        for (var k in Jscex.BuilderBase.prototype) {
            AsyncBuilder.prototype[k] = Jscex.BuilderBase.prototype[k];
        }

        /* ---------------- Export ---------------- */

        Jscex.Async = Jscex.Async || {};
        Jscex.Async.CancellationToken = CancellationToken;
        Jscex.Async.CanceledError = CanceledError;
        Jscex.Async.Task = Task;
        Jscex.Async.AsyncBuilder = AsyncBuilder;

        Jscex.builders = Jscex.builders || {};
        Jscex.binders.async = "$await";
        Jscex.builders.async = new AsyncBuilder();

        Jscex.modules.async = true;
    };

    /* ---------------- Module Loader ---------------- */

    if (typeof require === "function" && typeof module !== "undefined" && module.exports) {
        module.exports.init = function (Jscex) {
            if (!Jscex.modules.builderbase) {
                require("jscex-builderbase").init(Jscex);
            }
            initAsync(Jscex);
        };
    } else if (typeof define === "function" && !define.amd) {
        define("jscex-async", ["jscex-builderbase"], function (b, d, e) {
            e.exports.init = function (Jscex) {
                Jscex.modules.builderbase || b("jscex-builderbase").init(Jscex);
                initAsync(Jscex);
            };
        });
    } else if (typeof define === "function" && define.amd) {
        define("jscex-async", ["jscex-builderbase"], function (b) {
            return {
                init: function (Jscex) {
                    Jscex.modules.builderbase || b.init(Jscex);
                    initAsync(Jscex);
                }
            };
        });
    } else {
        if (typeof Jscex === "undefined") {
            throw Error('Missing the root object, please load "jscex" module first.');
        }
        if (!Jscex.modules.builderbase) {
            throw Error(
                'Missing essential components, please initialize "builderbase" module first.'
            );
        }
        initAsync(Jscex);
    }

})();
